---
title: "Analyzing portfolio effects in commercial catch data"
author: "NCEAS commercial catch portfolio working group"
date: "February 22, 2016"
output:
  pdf_document:
    fig_caption: yes
  html_document: default
---

## Overview
We are interested in multiple metrics of diversity. For this first paper, we plan to divide the analysis into several components:  
1. Characterize trends in diversity over time (using GAMs). The metrics of diversity we might want to include are  
- variation in species diversity  
- variation in gear diversity  
- variation in spatial diversity (number of commercial areas fished?)  
- variation in permit holdings over time  
2. Using diversity as the predictor, look at absolute or relative change revenue / vessel (or revenue / vessel / days fished) as the response.  

For both of the above, there's a large number of other perturbations including EVOS, management changes, climate shifts, changes in gear or processsing capacity, hatchery production of salmon, market conditions (such as Japanese crash in mid-1990s), constraints on limited entry or quotas, and biological conditions or shifts (abundance, distribution, size structure, etc). 

We'll initially restrict our analysis to data after 1984, since the data from 1975-1984 were dominated by foreign vessels (which we don't have). For more information, see AFSC technical reports (such as http://www.afsc.noaa.gov/Publications/AFSC-TM/NOAA-TM-AFSC-54.pdf). The cutoff of 1984/1985 is also consistent with the ADFG use. Further, the species reporting changes drastically before / after 1985 -- examples include no rockfish (demersal, pelagic, slope categories below), flatfish (shallow, deep categories below).  

Additional information on CFEC data here,  
Gear descriptions: https://www.cfec.state.ak.us/misc/GEARDESC.HTM  
Fishery codes: https://www.cfec.state.ak.us/misc/FshyDesC.htm  
Species and gear codes:   https://www.adfg.alaska.gov/static/license/fishing/pdfs/elanding_codes.pdf  
Commercial areas: http://www.adfg.alaska.gov/index.cfm?adfg=fishingCommercialByFishery.statmaps  
Halibut areas: http://www.iphc.int/publications/techrep/tech0049.pdf  

```{r chunkSet, cache=FALSE, echo=FALSE,warning=FALSE,message=FALSE}
library(MASS)
library(knitr)
library(dplyr)
library(ggplot2)
library(vegan)
library(mgcv)
library(lme4)
library(scales)
library(fields)
library(reshape)
library(reshape2)
library(cluster)
opts_chunk$set(tidy=TRUE, message=FALSE)
```

## Data processing
Load the data from the saved workspace. This is the raw cfec data that has been merged to have the same columns across years, 1975 - present. The key columns are the species labels ("spec") and species number codes ("specn"), the gear number codes ("gearn"), the vessel id ("adfg"), the area where the catch occurred ("stat6"), the pounds harvested ("g_pounds"), gross earnings ("g_earn").  

### Note: for any confidentiality concerns, the workspace loaded here has been slightly jittered. This will need to be replaced with the real data for the final model. 
```{r loadData}
load("cfec.Rdata")
# initially only use data 1985+
cfec = cfec[cfec$year>1984,]
```

The first data processing step is to aggregate some of the species. This is largely needed because of changes in reporting over time (before 1985 for example, lots of the catch was from foreign fleets & not reported to species level -- for example, some of the rockfishes). For other species, there are unidentified groups, so there's additional aggregation required. 

```{r specLump}
# Lump all skates together
cfec$spec = as.character(cfec$spec)
cfec$specn[cfec$specn==700] = 700
cfec$specn[cfec$specn==701] = 700
cfec$specn[cfec$specn==702] = 700
cfec$spec[cfec$specn==700] = "SKATE"

# Lump all sharks together
cfec$specn[cfec$specn==691] = 689
cfec$specn[cfec$specn==689] = 689
cfec$spec[cfec$specn==689] = "SHARK"

# Lump flatfish (Shallow)
cfec$specn[cfec$specn==123] = 119 # rock
cfec$specn[cfec$specn==129] = 119 # starry flounder
cfec$specn[cfec$specn==127] = 119 # yellowfin
cfec$specn[cfec$specn==126] = 119 # butter
cfec$spec[cfec$specn==119] = "FLAT.shallow"
# 5, 6, 7, 15, 26, 47, 61, 
# Lump flatfish (deep)
cfec$specn[cfec$specn==124] = 118 # dover
cfec$specn[cfec$specn==134] = 118 # greenland turbot
cfec$spec[cfec$specn==118] = "FLAT.deep"

# Lump rockfish, codes from here:
cfec$specn[cfec$specn==141] = 144 # POP
cfec$specn[cfec$specn==136] = 144 # northern
cfec$specn[cfec$specn==151] = 144 # rougheye
cfec$specn[cfec$specn==166] = 144 # sharpchin
cfec$specn[cfec$specn==152] = 144 # shortraker
cfec$specn[cfec$specn==153] = 144 # redbanded
cfec$specn[cfec$specn==157] = 144 # silvergray
cfec$specn[cfec$specn==158] = 144 # redstripe
cfec$specn[cfec$specn==137] = 144 # bocaccio
cfec$specn[cfec$specn==144] = 144 # unid
cfec$spec[cfec$specn==144] = "ROCK.slope"

cfec$specn[cfec$specn==138] = 168 # copper
cfec$specn[cfec$specn==145] = 168 # yelloweye
cfec$specn[cfec$specn==146] = 168 # Canary
cfec$specn[cfec$specn==147] = 168 # quillback
cfec$specn[cfec$specn==148] = 168 # tiger
cfec$specn[cfec$specn==149] = 168 # China
cfec$specn[cfec$specn==150] = 168 # rosethorn
cfec$spec[cfec$specn==168] = "ROCK.demersal"

cfec$specn[cfec$specn==154] = 169 # dusky
cfec$specn[cfec$specn==155] = 169 # yellowtail
cfec$specn[cfec$specn==156] = 169 # widow
cfec$specn[cfec$specn==172] = 169 # dusky
cfec$specn[cfec$specn==173] = 169 # dark
cfec$specn[cfec$specn==142] = 169 # black
cfec$specn[cfec$specn==167] = 169 # blue
cfec$spec[cfec$specn==169] = "ROCK.pelagic"

# Lump king crabs
cfec$spec[cfec$spec%in%c("GKCR","BKCR","UKCR","RKCR")] = "KCRB" # king
# Lump tanner crabs
cfec$spec[cfec$spec%in%c("UTCR","BTCR")] = "TCRB" # tanner
# Lump shrimp - spot prawn, pink shrimp, 
cfec$spec[cfec$spec%in%c("SPRW","PSHP","USRM")] = "USRM" # shrimp
# Correct REX and "REX "
cfec$spec[cfec$spec%in%c("REX ")] = "REX"
# drop records with no spp
cfec = cfec[-which(cfec$spec==""),]
```

Next, we have to clean up a few of the gears. Drop a few gears that are sporadically used, and combine longline gears.

```{r}
# 8 = fishwheel, used at start / end
# 13 = dipnet, only last 2 years
# 99 = other, stopped reporting
cfec = cfec[-which(cfec$gearn%in%c(8, 13, 99)),]
# Merge 6 and 61 into longline
cfec$gearn[which(cfec$gearn==61)] = 6
```

Next, we'll deal with processing the areas. We have multiple types of area codes. The 6-digit codes represent groundfish management areas, the 5-digit codes are state salmon/shellfish areas, and the 3-digit codes are the halibut areas. For the groundfish and salmon areas, there are sub-areas that are also reported (as the last 2-digits), so we'll lump sub-areas together by stripping off the last 2-digits.  
  
```{r}
# Filter out sub-districts and group things at larger areas
# Lump statistical areas by district -- groundfish
cfec$stat6 = as.numeric(cfec$stat6) # as.numeric needed because of integer
cfec$areaType = NA
cfec$stat6_char = NA
indx = which(cfec$stat6 > 99999 & cfec$stat6 < 999999)
cfec$stat6_char[indx] = nchar(as.character(cfec$stat6[indx]))
cfec$areaType[indx] = "groundfish"
# This is just turning the last digit - sub region - into 0
cfec$stat6[indx] = as.numeric(paste(substr(as.character(cfec$stat6[indx]),1,5), "0",sep=""))
# Now do salmon / shellfish - This is just turning the last 2 digits - sub region - into 00
indx = which(cfec$stat6 > 9999 & cfec$stat6 < 100000)
cfec$stat6[indx] = as.numeric(paste(substr(as.character(cfec$stat6[indx]), 1, 3), "00", sep=""))
cfec$areaType[indx] = "salmonShellfish"

# Deal with the IPHC areas too. We can verify that nearly all spp caught in 3-digit areas are halibut,
#sort(table(cfec$spec[which(cfec$stat6 < 1000)]))
```

Next, we'll aggregate the stat6 codes into larger geographic regions. The focus here is on Prince William Sound, but for contrast we'll include Southeast Alaska, Kodiak W / E, Cook Inlet, and Bristol Bay. 

```{r}
# Add the areas -- 5 digit are salmon/shellfish, 6-digit are groundfish
cfec$area = NA
cfec$area[cfec$stat6==485900] = "PWS"
cfec$area[cfec$stat6==475900] = "PWS"
cfec$area[cfec$stat6==465900] = "PWS"
cfec$area[cfec$stat6==455900] = "PWS"
cfec$area[cfec$stat6==445900] = "PWS"
cfec$area[cfec$stat6==495930] = "PWS"
cfec$area[cfec$stat6==485930] = "PWS"
cfec$area[cfec$stat6==475930] = "PWS"
cfec$area[cfec$stat6==465930] = "PWS"
cfec$area[cfec$stat6==455930] = "PWS"
cfec$area[cfec$stat6==445930] = "PWS"
cfec$area[cfec$stat6==486000] = "PWS"
cfec$area[cfec$stat6==476000] = "PWS"
cfec$area[cfec$stat6==466000] = "PWS"
cfec$area[cfec$stat6==456000] = "PWS"
cfec$area[cfec$stat6==446000] = "PWS"
cfec$area[cfec$stat6==486030] = "PWS"
cfec$area[cfec$stat6==476030] = "PWS"
cfec$area[cfec$stat6==466030] = "PWS"
cfec$area[cfec$stat6==456030] = "PWS"
cfec$area[cfec$stat6==486100] = "PWS"
cfec$area[cfec$stat6==476100] = "PWS"
cfec$area[cfec$stat6==466100] = "PWS"
cfec$area[which(cfec$stat6 < 20099 & cfec$stat6 >= 20000)] = "PWS"
cfec$area[which(cfec$stat6 < 21299 & cfec$stat6 >= 21200)] = "PWS"
cfec$area[which(cfec$stat6 < 22799 & cfec$stat6 >= 22700)] = "PWS"  
cfec$area[which(cfec$stat6 < 22699 & cfec$stat6 >= 22600)] = "PWS"
cfec$area[which(cfec$stat6 < 22899 & cfec$stat6 >= 22800)] = "PWS"
cfec$area[which(cfec$stat6 < 22199 & cfec$stat6 >= 22100)] = "PWS"
cfec$area[which(cfec$stat6 < 22299 & cfec$stat6 >= 22200)] = "PWS"  
cfec$area[which(cfec$stat6 < 22599 & cfec$stat6 >= 22500)] = "PWS"
cfec$area[which(cfec$stat6 < 22499 & cfec$stat6 >= 22400)] = "PWS"
cfec$area[which(cfec$stat6 < 22399 & cfec$stat6 >= 22300)] = "PWS" 
# Add halibut areas
cfec$area[cfec$stat6 %in% c(242,232,220,230,240)] = "PWS"

cfec$area[cfec$stat6==525900] = "CookInlet"
cfec$area[cfec$stat6==535900] = "CookInlet"
cfec$area[cfec$stat6==515930] = "CookInlet"
cfec$area[cfec$stat6==525930] = "CookInlet"
cfec$area[cfec$stat6==535930] = "CookInlet"
cfec$area[cfec$stat6==516000] = "CookInlet"
cfec$area[cfec$stat6==526000] = "CookInlet"
cfec$area[cfec$stat6==496030] = "CookInlet"
cfec$area[cfec$stat6==506030] = "CookInlet"
cfec$area[cfec$stat6==516030] = "CookInlet"
cfec$area[cfec$stat6==526030] = "CookInlet"
cfec$area[cfec$stat6==506100] = "CookInlet"
cfec$area[cfec$stat6==516100] = "CookInlet"
cfec$area[which(cfec$stat6 < 24799 & cfec$stat6 >= 24400)] = "CookInlet" 
cfec$area[which(cfec$stat6%in%c(261, 272))] = "CookInlet"

cfec$area[which(cfec$stat6 < 11599 & cfec$stat6 >= 11100)] = "Southeast"
cfec$area[which(cfec$stat6 < 10499 & cfec$stat6 >= 10100)] = "Southeast"
cfec$area[which(cfec$stat6 < 11099 & cfec$stat6 >= 10500)] = "Southeast" 
cfec$area[which(cfec$stat6 >= 305430 & cfec$stat6 <= 305530)] = "Southeast"
cfec$area[which(cfec$stat6 >= 315430 & cfec$stat6 <= 315600)] = "Southeast"
cfec$area[which(cfec$stat6 >= 325430 & cfec$stat6 <= 325700)] = "Southeast"
cfec$area[which(cfec$stat6 >= 335430 & cfec$stat6 <= 335800)] = "Southeast"
cfec$area[which(cfec$stat6 >= 345400 & cfec$stat6 <= 345830)] = "Southeast"
cfec$area[which(cfec$stat6 >= 355400 & cfec$stat6 <= 355900)] = "Southeast"
cfec$area[which(cfec$stat6 > 365400 & cfec$stat6 < 365830)] = "Southeast"
# For IPHC see Fig. 20 here: http://www.iphc.int/publications/techrep/tech0049.pdf
cfec$area[which(cfec$stat6%in%c(140, 141, 142, 143, 144, 150, 151, 152, 153, 160, 161, 162, 163, 170, 171, 172, 174, 174, 181, 182, 183, 184, 185))] = "Southeast"

# Kodiak east area is defined by halibut areas 270/280, includes ADFG salmon / 
# shellfish on E side of kodiak, and groundfish areas extending to NMFS Area 630
# boundary
cfec$area[cfec$stat6%in%c(270,280)] = "Kodiak.east"
cfec$area[which(cfec$stat6 < 25899 & cfec$stat6 >= 25800)] = "Kodiak.east"
cfec$area[which(cfec$stat6 < 25999 & cfec$stat6 >= 25900)] = "Kodiak.east"
cfec$area[cfec$stat6==535630] = "Kodiak.east"
cfec$area[cfec$stat6==525630] = "Kodiak.east"
cfec$area[cfec$stat6==515630] = "Kodiak.east"
cfec$area[cfec$stat6==505630] = "Kodiak.east"
cfec$area[cfec$stat6==495630] = "Kodiak.east"
cfec$area[cfec$stat6==535700] = "Kodiak.east"
cfec$area[cfec$stat6==525700] = "Kodiak.east"
cfec$area[cfec$stat6==515700] = "Kodiak.east"
cfec$area[cfec$stat6==505700] = "Kodiak.east"
cfec$area[cfec$stat6==495700] = "Kodiak.east"
cfec$area[cfec$stat6==525730] = "Kodiak.east"
cfec$area[cfec$stat6==515730] = "Kodiak.east"
cfec$area[cfec$stat6==505730] = "Kodiak.east"
cfec$area[cfec$stat6==495730] = "Kodiak.east"
cfec$area[cfec$stat6==525800] = "Kodiak.east"
cfec$area[cfec$stat6==515800] = "Kodiak.east"
cfec$area[cfec$stat6==505800] = "Kodiak.east"
cfec$area[cfec$stat6==495800] = "Kodiak.east"

cfec$area[cfec$stat6%in%c(271,281)] = "Kodiak.west"
cfec$area[cfec$stat6==535730] = "Kodiak.west"
cfec$area[cfec$stat6==545730] = "Kodiak.west"
cfec$area[cfec$stat6==525800] = "Kodiak.west"
cfec$area[cfec$stat6==535800] = "Kodiak.west"
cfec$area[cfec$stat6==545800] = "Kodiak.west"
cfec$area[cfec$stat6==535830] = "Kodiak.west"
cfec$area[cfec$stat6==525830] = "Kodiak.west"
cfec$area[which(cfec$stat6 < 25699 & cfec$stat6 >= 25500)] = "Kodiak.west"
cfec$area[which(cfec$stat6 < 25499 & cfec$stat6 >= 25300)] = "Kodiak.west"  
cfec$area[which(cfec$stat6 < 26299 & cfec$stat6 >= 26000)] = "Kodiak.west"

# Bristol Bay, defined as going west to the boundary between NMFS areas 512 / 516
cfec$area[cfec$stat6%in%c(31600, 31700, 31800, 32000, 32100, 32200, 32400, 32500, 32600)] = "BristolBay"
cfec$area[cfec$stat6%in%c(575730, 575800, 575830)] = "BristolBay"
cfec$area[cfec$stat6%in%c(585700, 585730, 585800, 585830)] = "BristolBay"
cfec$area[cfec$stat6%in%c(595630, 595700, 595730, 595800, 595830)] = "BristolBay"
cfec$area[cfec$stat6%in%c(605600, 605630, 605700, 605730, 605800, 605830)] = "BristolBay"
cfec$area[cfec$stat6%in%c(615600, 615630, 615700, 615730, 615800, 615830)] = "BristolBay"
   
# Area to add - Alaska peninsula - Halibut areas 300-340?
```
  
Another alternative approach to grouping would be to perform a cluster analysis on vessels / areas. Here we'll make a table of vessels (rows) and areas (column) then use 'clara' to construct 8 groups. This is somewhat arbitrary, but reflects roughly the number constructed above.  

```{r}
T = table(cfec$adfg, cfec$stat6)
CC = clara(T, k = 8)
cluster_vesselArea = t(CC$medoids)
```

Next we can sort out the mutually exclusive areas in the medoids to identify how the areas are being clustered.  
```{r}
cluster_vesselArea = ceiling(cluster_vesselArea / 1.0e10)
cluster_vesselArea = cluster_vesselArea[-which(apply(cluster_vesselArea,1,sum)!=1),]
```

For example, the 6th medoid is clearly pulling out vessels in Southeast, 
```{r}
names(which(cluster_vesselArea[,6]==1))
```

Similarly, medoid 1 is PWS, medoid 2 is Cook Inlet, medoid 4 is Bristol Bay, medoid 5 is ~ 700 records of halibut (from a southern area not in GoA), medoid 6 is Southeast, medoid 7 is Kodiak, medoids 3 and 8 are Bering. So this seems to agree with our clustering, maybe with the exception of not splitting Kodiak into W/E.

We can look at how the species landed varies by area (table in 1000s), 
```{r}
kable(round(table(cfec$spec, cfec$area)/1000, 2))
```

We can filter out rare species, and turn this table into catch composition (by occurence, not weight or earnings) to highlight how the areas are different,  

```{r}
specArea = table(cfec$spec, cfec$area)
# normalize by area
for(i in 1:dim(specArea)[2]) {
specArea[,i] = specArea[,i]/sum(specArea[,i])
}
kable(round(specArea[-which(apply(specArea,1,max) < 0.01),], 2))
```
  
## Exploratory data analysis

Drop all species records that have less than 1000 total observations. This is discarding about 5000 of 20 million records. 
```{r discardSpec}
cfecClean = group_by(cfec, spec) %>%
  mutate(nspecies = n()) %>%
  filter(nspecies > 1000) %>%
  data.frame
# Also drop out unid groundfish, unid flatfish, smelts, grenadier, english sole -- all very rare
cfecClean = cfecClean[-which(cfecClean$spec%in%c("UFLT","UGRN","SMLT","GRDR","EGLS")),]
```

Drop all species records with gears occuring < 1000 times. This is discarding about 1250 records.
```{r discardGear}
cfecClean = group_by(cfecClean, gearn) %>%
  mutate(ngears = n()) %>%
  filter(ngears > 1000) %>%
  data.frame
```

Delete catch from fisheries that have less than 100 total records. This simplifies the dimension of the fishery codes a lot (from 378 to 234), removes about 3050 records, and doesn't affect the total revenue (these fisheries represent 0.0009 of total g_earn).  
```{r discardFishery}
cfecClean = group_by(cfecClean, p_fshy) %>%
  mutate(nfshy = n()) %>%
  filter(nfshy > 100) %>%
  data.frame

# Write the SSL related sites to a workspace
sslStat6 = c(355630,
365730, 375830, 345530, 335430, 335430, 335430,
335430, 335430, 365800, 355700, 345530, 355630,
355700, 335700, 335700, 355700, 445930, 495930, 
476000, 485930, 495930, 325600, 495930, 476000,
475930, 555530, 565600, 525700, 525700, 525830,
525700, 515800, 515830, 535630, 365800, 575630,
535630, 565630, 525830, 595500, 595430, 595500,
595430, 635430, 635430, 605430, 615430, 635504,
585500)

# calculate areas in circle around square of interest
sslStat6.square = c(sslStat6, sslStat6 +- 9970, sslStat6 +- 10000, 
sslStat6 +- 10070, sslStat6 +- 70, sslStat6 +- 9930, sslStat6 +- 10000, 
sslStat6 +- 10030, sslStat6 +- 30)
sslStat6.label = rep(sslStat6,9)

cfecSSL = cfecClean[cfecClean$stat6%in%sslStat6.square,]
cfecSSL$label = sslStat6.label[match(cfecSSL$stat6, sslStat6.square)]
save(cfecSSL, file="cfecSSL.Rdata")

```

Tabulate the gears and species remaining.  
```{r tableOfGears}
m = as.matrix(sort(table(cfecClean$gearn)), ncol=1)
# Normalize percent of all records
m = cbind(m, round(100*m[,1]/sum(m[,1]),2))
colnames(m) = c("Records","Percent")
kable(m)
```

This shows that 79% of the records in the database are salmon!   
```{r tableOfSpec}
m = as.matrix(sort(table(cfecClean$spec)), ncol=1)
# Normalize percent of all records
m = cbind(m, round(100*m[,1]/sum(m[,1]),2))
colnames(m) = c("Records","Percent")
kable(m)
```

Subset the data to only include vessels that ever fished in Prince William Sound. This data frame becomes 'cfecPWS'.

```{r useOnlyPWS}
cfecPWS = group_by(cfecClean, adfg) %>%
  mutate(in_PWS = any(area%in%"PWS")) %>%
  as.data.frame() %>%
  filter(in_PWS) %>%
  data.frame
```

Alan suggested looking at some coarse plots. First, we can show participation of vessels over time. Halibut fishing pre-1995 needed to get quota by catching halibut in 1988-1990.  
```{r,fig.cap="Time series of participation by year",fig.pos="placeHere"}
plot(min(cfecPWS$year):max(cfecPWS$year), specnumber(table(cfecPWS$year,cfecPWS$adfg)), xlab="",ylab="# Vessels", type="b", main = "Participation in PWS region")
```
  
We can also look at species landed by year. This is not terribly informative -- for example the total number of species landed in the dataset has ranged from 38-41. An alternative would be to take the average (below).  
  
```{r,fig.cap="Time series of species caught by year",fig.pos="placeHere"}
# total species
par(mfrow = c(3,1), mgp = c(2,1,0), mai=c(0.5,0.5,0.3,0.1))
plot(min(cfecPWS$year) : max(cfecPWS$year) , 
     specnumber( table (cfecPWS$year, cfecPWS$spec)), xlab="", 
     ylab="# Species", type="b", 
     main="Catch from vessels that ever fished in PWS")

plot(min(cfecPWS$year) : max(cfecPWS$year), 
     specnumber(table(cfecPWS$year[cfecPWS$area=="PWS"], 
                      cfecPWS$spec[cfecPWS$area=="PWS"])), 
     xlab="",ylab="# Species", type="b",main="Catch only in PWS")

plot(min(cfecClean$year) : max(cfecClean$year), 
     specnumber(table(cfecClean$year,  cfecClean$spec)), 
     xlab="",ylab="# Species", type="b", 
     main="All vessels in dataset")
```

Now we can calculate the average species landed / year, where the average is calculated as the total number of species landed divided by the total number of vessels fishing. 
  
```{r,fig.cap="Time series of avg species caught by year per vessel",fig.pos="placeHere"}
# total species
par(mfrow = c(3,1), mgp = c(2,1,0), mai=c(0.5,0.5,0.3,0.1))
plot(min(cfecPWS$year):max(cfecPWS$year), 
     specnumber(table(cfecPWS$year, cfecPWS$spec)) / 
       specnumber(table(cfecPWS$year,  cfecPWS$adfg)), 
     xlab="", ylab="Avg # Species / Ves", 
     type="b", main="Catch from vessels that ever fished in PWS")

plot(min(cfecPWS$year):max(cfecPWS$year), 
     specnumber(table(cfecPWS$year[cfecPWS$area=="PWS"], 
     cfecPWS$spec[cfecPWS$area=="PWS"])) / 
       specnumber(table(cfecPWS$year[cfecPWS$area=="PWS"], 
     cfecPWS$adfg[cfecPWS$area=="PWS"])), 
     xlab="",ylab="Avg # Species / Ves", 
     type="b",main="Catch only in PWS")

plot(min(cfecClean$year):max(cfecClean$year), 
     specnumber(table(cfecClean$year,  cfecClean$spec)) / 
       specnumber(table(cfecClean$year,  cfecClean$adfg)), 
     xlab="",ylab="Avg # Species / Ves",
     type="b", main="All vessels in dataset")
```
  
Another way to calculate the average is total # species landed divided by the total number of fishing records per year.  
  
```{r,fig.cap="Time series of avg species caught by year per vessel",fig.pos="placeHere"}
# total species
par(mfrow = c(3,1), mgp = c(2,1,0), mai=c(0.5,0.5,0.3,0.1))
plot(min(cfecPWS$year):max(cfecPWS$year), 
     specnumber(table(cfecPWS$year, cfecPWS$spec)) / 
       as.numeric(table(cfecPWS$year)), xlab="", 
     ylab = "Avg # Species / Haul", type = "b",  
     main = "Catch from vessels that ever fished in PWS")

plot(min(cfecPWS$year):max(cfecPWS$year), 
     specnumber(table(cfecPWS$year[cfecPWS$area=="PWS"], 
    cfecPWS$spec[cfecPWS$area=="PWS"])) / 
      as.numeric(table(cfecPWS$year[cfecPWS$area=="PWS"])), 
    xlab = "", ylab = "Avg # Species / Haul", 
    type = "b",main = "Catch only in PWS")

plot(min(cfecClean$year):max(cfecClean$year), 
     specnumber(table(cfecClean$year,  cfecClean$spec)) / 
       as.numeric(table(cfecClean$year)), xlab = "", 
     ylab = "Avg # Species / Haul", 
     type = "b", main = "All vessels in dataset")
```
  
Look at species diversity using Vegan. How has diversity in # species fished changed over time?   
```{r veganSpecies,echo=FALSE, fig.cap="Time series of species diversity (for vessels that have ever fished in Prince William Sound)",fig.pos="placeHere"}
nSpecies.mean = NA # mean richness
nSpecies.cv = NA # cv richness
simp.mean = NA # mean simpson
simp.cv = NA # cv simpson
shannon.mean = NA # mean shannon
shannon.cv = NA # cv shannon
for(yr in min(cfecPWS$year):max(cfecPWS$year)) {
  nSpecies.mean[yr+1-min(cfecPWS$year)] = mean(specnumber(table(cfecPWS$adfg[cfecPWS$year==yr], cfecPWS$spec[cfecPWS$year==yr])))
   nSpecies.cv[yr+1-min(cfecPWS$year)] = sd(specnumber(table(cfecPWS$adfg[cfecPWS$year==yr], cfecPWS$spec[cfecPWS$year==yr])))/nSpecies.mean[yr+1-min(cfecPWS$year)]
  simp.mean[yr+1-min(cfecPWS$year)] = mean(diversity(table(cfecPWS$adfg[cfecPWS$year==yr], cfecPWS$spec[cfecPWS$year==yr]),index="invsimpson"))
  simp.cv[yr+1-min(cfecPWS$year)] = sd(diversity(table(cfecPWS$adfg[cfecPWS$year==yr], cfecPWS$spec[cfecPWS$year==yr]),index="invsimpson"))/simp.mean[yr+1-min(cfecPWS$year)]
  shannon.mean[yr+1-min(cfecPWS$year)] = mean(diversity(table(cfecPWS$adfg[cfecPWS$year==yr], cfecPWS$spec[cfecPWS$year==yr])))
  shannon.cv[yr+1-min(cfecPWS$year)] = sd(diversity(table(cfecPWS$adfg[cfecPWS$year==yr], cfecPWS$spec[cfecPWS$year==yr])))/simp.mean[yr+1-min(cfecPWS$year)]  
}

par(mfrow = c(3,2), mgp=c(2,1,0),mai=c(0.3,0.5,0.1,0.1))
plot(min(cfecPWS$year):max(cfecPWS$year),nSpecies.mean,ylab="Mean species richness",type="b")
plot(min(cfecPWS$year):max(cfecPWS$year),nSpecies.cv,ylab="CV species richness",type="b")
plot(min(cfecPWS$year):max(cfecPWS$year),simp.mean,ylab="Mean simpson div",type="b")
plot(min(cfecPWS$year):max(cfecPWS$year),simp.cv,ylab="CV simpson div",type="b")
plot(min(cfecPWS$year):max(cfecPWS$year),shannon.mean,ylab="Mean Shannon div",type="b")
plot(min(cfecPWS$year):max(cfecPWS$year),shannon.cv,ylab="CV Shannon div",type="b")
```
  
We can do similar plots for the number of gears used / vessel  
```{r veganGears,echo=FALSE, fig.cap="Time series of diversity of number of fishing gears (for vessels that have ever fished in Prince William Sound)",fig.pos="placeHere"}
nGears.mean = NA # mean richness
nGears.cv = NA # cv richness
simp.mean = NA # mean simpson
simp.cv = NA # cv simpson
shannon.mean = NA # mean shannon
shannon.cv = NA # cv shannon
for(yr in min(cfecPWS$year):max(cfecPWS$year)) {
  nGears.mean[yr+1-min(cfecPWS$year)] = mean(specnumber(table(cfecPWS$adfg[cfecPWS$year==yr], cfecPWS$gearn[cfecPWS$year==yr])))
   nGears.cv[yr+1-min(cfecPWS$year)] = sd(specnumber(table(cfecPWS$adfg[cfecPWS$year==yr], cfecPWS$gearn[cfecPWS$year==yr])))/nGears.mean[yr+1-min(cfecPWS$year)]
  simp.mean[yr+1-min(cfecPWS$year)] = mean(diversity(table(cfecPWS$adfg[cfecPWS$year==yr], cfecPWS$gearn[cfecPWS$year==yr]),index="invsimpson"))
  simp.cv[yr+1-min(cfecPWS$year)] = sd(diversity(table(cfecPWS$adfg[cfecPWS$year==yr], cfecPWS$gearn[cfecPWS$year==yr]),index="invsimpson"))/simp.mean[yr+1-min(cfecPWS$year)]
  shannon.mean[yr+1-min(cfecPWS$year)] = mean(diversity(table(cfecPWS$adfg[cfecPWS$year==yr], cfecPWS$gearn[cfecPWS$year==yr])))
  shannon.cv[yr+1-min(cfecPWS$year)] = sd(diversity(table(cfecPWS$adfg[cfecPWS$year==yr], cfecPWS$gearn[cfecPWS$year==yr])))/simp.mean[yr+1-min(cfecPWS$year)]  
}

par(mfrow = c(3,2), mai=c(0.3,0.5,0.1,0.1))
plot(min(cfecPWS$year):max(cfecPWS$year),nGears.mean,ylab="Mean gear richness",type="b")
plot(min(cfecPWS$year):max(cfecPWS$year),nGears.cv,ylab="CV gear richness",type="b")
plot(min(cfecPWS$year):max(cfecPWS$year),simp.mean,ylab="Mean simpson div",type="b")
plot(min(cfecPWS$year):max(cfecPWS$year),simp.cv,ylab="CV simpson div",type="b")
plot(min(cfecPWS$year):max(cfecPWS$year),shannon.mean,ylab="Mean Shannon div",type="b")
plot(min(cfecPWS$year):max(cfecPWS$year),shannon.cv,ylab="CV Shannon div",type="b")
```
  
And we can do similar plots for permit types per vessel  
```{r veganPermits,echo=FALSE, fig.cap="Time series of diversity of number of permits used",fig.pos="placeHere"}
nPermits.mean = NA # mean richness
nPermits.cv = NA # cv richness
simp.mean = NA # mean simpson
simp.cv = NA # cv simpson
shannon.mean = NA # mean shannon
shannon.cv = NA # cv shannon
for(yr in min(cfecPWS$year):max(cfecPWS$year)) {
  nPermits.mean[yr+1-min(cfecPWS$year)] = mean(specnumber(table(cfecPWS$adfg[cfecPWS$year==yr], cfecPWS$p_fshy[cfecPWS$year==yr])))
   nPermits.cv[yr+1-min(cfecPWS$year)] = sd(specnumber(table(cfecPWS$adfg[cfecPWS$year==yr], cfecPWS$p_fshy[cfecPWS$year==yr])))/nPermits.mean[yr+1-min(cfecPWS$year)]
  simp.mean[yr+1-min(cfecPWS$year)] = mean(diversity(table(cfecPWS$adfg[cfecPWS$year==yr], cfecPWS$p_fshy[cfecPWS$year==yr]),index="invsimpson"))
  simp.cv[yr+1-min(cfecPWS$year)] = sd(diversity(table(cfecPWS$adfg[cfecPWS$year==yr], cfecPWS$p_fshy[cfecPWS$year==yr]),index="invsimpson"))/simp.mean[yr+1-min(cfecPWS$year)]
  shannon.mean[yr+1-min(cfecPWS$year)] = mean(diversity(table(cfecPWS$adfg[cfecPWS$year==yr], cfecPWS$p_fshy[cfecPWS$year==yr])))
  shannon.cv[yr+1-min(cfecPWS$year)] = sd(diversity(table(cfecPWS$adfg[cfecPWS$year==yr], cfecPWS$p_fshy[cfecPWS$year==yr])))/simp.mean[yr+1-min(cfecPWS$year)]  
}

par(mfrow = c(3,2), mai=c(0.3,0.5,0.1,0.1))
plot(min(cfecPWS$year):max(cfecPWS$year),nPermits.mean,ylab="Mean permit richness",type="b")
plot(min(cfecPWS$year):max(cfecPWS$year),nPermits.cv,ylab="CV permit richness",type="b")
plot(min(cfecPWS$year):max(cfecPWS$year),simp.mean,ylab="Mean simpson div",type="b")
plot(min(cfecPWS$year):max(cfecPWS$year),simp.cv,ylab="CV simpson div",type="b")
plot(min(cfecPWS$year):max(cfecPWS$year),shannon.mean,ylab="Mean Shannon div",type="b")
plot(min(cfecPWS$year):max(cfecPWS$year),shannon.cv,ylab="CV Shannon div",type="b")
```  
  
```{r, echo=FALSE,include=FALSE}
group_by(cfecPWS, adfg) %>% 
  summarize(n = length(unique(year))) %>% 
  ggplot(aes(n)) + geom_histogram() 
# To do: 7 - year peaks are weird. Survey? 
```
  
Make exploratory plot of vessels that fished only before and after 1989. These aren't shown -- but we looked at them in Santa Barbara, and the major take home point is that more vessels left the fishery after 1989 than joined.
  
```{r,fig.cap="Histogram of vessels that only fished in PWS before 1990",fig.pos="placeHere", include=FALSE,echo=FALSE}
group_by(cfecPWS, adfg) %>%  
mutate(before = ifelse(min(year) < 1990, 1, 0)) %>%  
  filter(before == 1) %>%  
  summarize(n = length(unique(year))) %>%  
  ggplot(aes(n)) + geom_histogram()  
```
  
```{r,fig.cap="Histogram of vessels that only fished in PWS after 1990",fig.pos="placeHere", include=FALSE,echo=FALSE}
group_by(cfecPWS, adfg) %>%  
mutate(after = ifelse(min(year) >= 1990, 1, 0)) %>%  
  filter(after == 1) %>%  
  summarize(n = length(unique(year))) %>%  
  ggplot(aes(n)) + geom_histogram()  
```
  
## Metric of change
We can use absolute or relative revenue over time, by vessel. We adopted the relative measure, because we're comparing vessels of very different size classes. Sizes of individual vessels may change slowly over time. The revenue metric is calculated as the first-differenced log revenue from time (t+1) to time (t), $log(earn_{t+1}) - log(earn_{t})$. 

The key challenge here is that we need a metric of revenue that will allow us to compare different types of vessels (e.g. large, small) that don't overlap in time. For example, we need a metric that standardizes catches or revenue from a small vessel fishing 1985-1990 to that of a large vessel fishing 2000-2005. The relative change is universal across vessels, and can be interpreted as percent change (e.g. a value of -1 = exp(-1) = 0.367, or a ~ 63% decline in revenue between years).  

We'll need to be cautious in putting together the covariates if the response is first differenced. If we code up indicators for press / pulse perturbations, those need to be first differenced too. 

## Aggregating data
The dataset currently is individual records. This needs to be aggregated by vessel / year, so there are totals for each individual vessel. The 3 key dimensions we want to explore with variability are diversity in (1) species, (2) gears, and (3) areas. Diversity in fishery permits is also included for exploration, but permits confounds areas, species, and gears. We need to do some lumping, so we'll initially aggregate  
- 10 or more species  
- 2 or more areas  
- 3 or more gears  
- 4 or more fisheries  
  
```{r aggregatePWSVessels}
totalPWS = group_by(cfecPWS, adfg, year) %>%
  summarize(totalearnings = sum(g_earn), 
            nspecies = length(unique(spec)),  
            ngear = length(unique(gearn)),  
            narea = length(unique(area)), 
            nfishery = length(unique(p_fshy))) 
# Lump larger groups
totalPWS$nspecies[totalPWS$nspecies>10] = 10
totalPWS$narea[totalPWS$narea>2] = 2
totalPWS$ngear[totalPWS$ngear>3] = 3
totalPWS$nfishery[totalPWS$nfishery>4] = 4
```
  
Add in NAs for missing years. We need these values to be included so that when we first difference, we're not taking differences across > 1 year. When we take the differences, we're also having variables for number of species, gears, etc (along with the differences of each predictor). For the undifferenced data, the number of species, gears, etc. corresponds to the value in the second year. We may want to replace this with a 2-year mean or something.  
  
```{r mergeYears}
dummyDF = expand.grid(adfg = unique(totalPWS$adfg), 
  year = min(totalPWS$year) : max(totalPWS$year), 
  stringsAsFactors = F)
# expand the data frame w/missing years
totalPWSExp = left_join(dummyDF, totalPWS) %>%
  arrange(adfg, year)
totalPWSExp = group_by(totalPWSExp, adfg) %>%
  mutate(difflog = c(NA, diff(log(totalearnings))), 
         diffspec = c(NA, diff(nspecies)),
         diffgear = c(NA, diff(ngear)),
         diffarea = c(NA, diff(narea)),
         difffishery = c(NA, diff(nfishery))) %>%
  filter(!is.na(difflog))
```

Now with our aggregated dataset, we can make histograms of each predictor.  
  
```{r,fig.cap="Histogram of predictors (across all years and data)",fig.pos="placeHere"}
par(mfrow = c(2,2), mai=c(0.6,0.6,0.1,0.1))
#hist(log(totalPWSExp$totalearnings), main="Log of revenue",xlab="",col="grey")
hist(totalPWSExp$nspecies, main="Number of species", xlab="", col="grey")
hist(totalPWSExp$ngear, main="Number of gears", xlab="", col="grey")
hist(totalPWSExp$narea, main="Number of areas", xlab="", col="grey")
hist(totalPWSExp$nfishery, main="Number of fisheries", xlab="", col="grey")
```
  
We can also look at change in these predictors over time -- we can also look at the response, which is change in revenue from time t to time t+1.
```{r,fig.cap="Histogram of change in predictors (across all years and data)",fig.pos="placeHere"}
par(mfrow = c(3,2), mai=c(0.6,0.6,0.2,0.1))
hist(totalPWSExp$difflog, main="Log of change in revenue", xlab="", col="grey")
hist(totalPWSExp$diffspec, main="Change in species", xlab="", col="grey")
hist(totalPWSExp$diffgear, main="Change in gears", xlab="", col="grey")
hist(totalPWSExp$diffarea, main="Change in areas", xlab="", col="grey")
hist(totalPWSExp$difffishery, main="Change in fisheries", xlab="", col="grey")
```
  
## Plotting change in revenue through time

We can start by making plots for individual data points where the dimension doesn't change (e.g. individuals fish 1 species in both time t and time t+1).

```{r,fig.cap="Median and quartiles of change in revenue, by species, for individuals that don't change number of species fished through time",fig.pos="placeHere"}
group_by(totalPWSExp[totalPWSExp$diffspec==0, ], year, nspecies) %>%  
  summarize(medDiffLog = median(difflog),  
  lower = quantile(difflog,probs = 0.25),  
  upper = quantile(difflog,probs = 0.75)) %>%  
ggplot(aes(year, medDiffLog)) + geom_line() + facet_wrap(~nspecies) +  geom_ribbon(aes(ymin=lower, ymax=upper), alpha=0.2)
```
  
```{r,fig.cap="Median and quartiles of change in revenue, by gears, for individuals that don't change number of gears fished through time",fig.pos="placeHere"}
group_by(totalPWSExp[totalPWSExp$diffgear==0, ], year, ngear) %>%  
  summarize(medDiffLog = median(difflog),  
  lower = quantile(difflog,probs = 0.25),  
  upper = quantile(difflog,probs = 0.75)) %>%  
ggplot(aes(year, medDiffLog)) + geom_line() + facet_wrap(~ngear) +  geom_ribbon(aes(ymin=lower, ymax=upper), alpha=0.2)
```
  
```{r,fig.cap="Median and quartiles of change in revenue, by areas, for individuals that don't change number of areas fished through time",fig.pos="placeHere"}
group_by(totalPWSExp[totalPWSExp$diffarea==0, ], year, narea) %>%  
  summarize(medDiffLog = median(difflog),  
  lower = quantile(difflog,probs = 0.25),  
  upper = quantile(difflog,probs = 0.75)) %>%  
ggplot(aes(year, medDiffLog)) + geom_line() + facet_wrap(~narea) +  geom_ribbon(aes(ymin=lower, ymax=upper), alpha=0.2)
```
  
```{r,fig.cap="Median and quartiles of change in revenue, by areas, for individuals that don't change number of fisheries fished through time",fig.pos="placeHere"}
group_by(totalPWSExp[totalPWSExp$difffishery==0, ], year, nfishery) %>%  
  summarize(medDiffLog = median(difflog),  
  lower = quantile(difflog,probs = 0.25),  
  upper = quantile(difflog,probs = 0.75)) %>%  
ggplot(aes(year, medDiffLog)) + geom_line() + facet_wrap(~nfishery) +   geom_ribbon(aes(ymin=lower, ymax=upper), alpha=0.2)
```
  
We can break the differences out further, by species (across columns) and by number of areas fished. The areas are grouped by vessels fishing in one area (just PWS) versus vessels that fish in PWS and 1 or more other regions. This plot includes some confounding, so don't read too much into it. 
```{r,fig.cap="Median and quartiles of change in revenue, by species x areas",fig.pos="placeHere"}
totalPWSExp2 = totalPWSExp 
totalPWSExp2$nspecies[totalPWSExp2$nspecies > 5] = 5
group_by(totalPWSExp2, year, nspecies, narea) %>%  
  summarize(medDiffLog = median(difflog),  
            lower = quantile(difflog,probs = 0.25),  
            upper = quantile(difflog,probs = 0.75)) %>%  
  ggplot(aes(year, medDiffLog)) + geom_line() + facet_grid(narea~nspecies) +   geom_ribbon(aes(ymin=lower, ymax=upper), alpha=0.2) 
```
  
Make some summary tables of vessels fishing in 1988 / 1989 that only landed one species. Make tables of the most common species landed, both by records and revenue. 
```{r}
vOne = filter(totalPWSExp,nspecies==1 & diffspec==0) %>%
  select(adfg) %>% #select(year,adfg)
  unique

LJ = left_join(vOne, cfecPWS)

# Look at species that fishers are specializing on
head(table(LJ$spec[LJ$year%in%seq(1988,1989)]) %>%
  sort %>%
  rev)

# Look at revenue of fishers that people are specializing on
LJ89 = LJ[LJ$year==1989,]
LJ89table = aggregate(g_earn ~ spec, LJ89, sum)
head(LJ89table[with(LJ89table, order(-g_earn)), ])

```
  
We can also get really into the weeds and make plots of individual annual landings, by vessel and species. For confidentiality, these aren't shown but the code can be run.  
```{r,include=FALSE,echo=FALSE}
#LJsummarized = group_by(LJ, year, spec,adfg) %>%
#  summarize(total=sum(g_earn)) %>%
#  as.data.frame() %>%
#  arrange(adfg, year, spec)
#ggplot(LJsummarized[1:10000,], aes(year,total,color=spec)) + geom_line()+facet_wrap(~adfg, scales="free_y")
```
  
## Fitting models to data
  
Before we fit anything, we need to calculate the mean of each predictor (# species, gears, areas) over the 2 year period. This will basically scale the effect, and will be included alongside predictors representing the change in each of these variables. 

Are a priori expectation is that if diversity (species, gear, area) is beneficial, all of the differenced predictors (diffspec, diffgear, diffarea) will have positive effects on the response (change in revenue). But if the differenced values are small, it means individual strategy is relatively constant, and we'd also expect the effects of diverification on the mean values (nspecies, narea, ngear).
  
```{r runningMean}
totalPWSExp$nspecies = (totalPWSExp$nspecies + (totalPWSExp$nspecies + totalPWSExp$diffspec))/2
totalPWSExp$ngear = (totalPWSExp$ngear + (totalPWSExp$ngear + totalPWSExp$diffgear))/2
totalPWSExp$narea = (totalPWSExp$narea + (totalPWSExp$narea + totalPWSExp$diffarea))/2
totalPWSExp$narea = (totalPWSExp$narea + (totalPWSExp$narea + totalPWSExp$diffarea))/2
```
  
Start with simple linear model, no random effects  
```{r linearModel}
lm.simple = lm(difflog~as.factor(year) + nspecies + ngear + narea + diffspec + diffgear + diffarea,data=totalPWSExp)
summary(lm.simple)
```
  
We can also fit a gam, with spline over year, and basically get the same result. These models show that changing strategy (increasing gears used or areas fished correlates with more revenue, but the overall strategy of more areas or gears doesn't have a positive effect). In contrast, the effect of species is positive in both, suggesting that fishing more species translates to positive revenue. Other splines can be included (nspecies, diffspec) but the effects are basically linear (not shown).  
  
```{r simpleGam}
gam.simple = gam(difflog~s(year) + nspecies + ngear + narea + diffspec + diffgear + diffarea,data=totalPWSExp)
summary(gam.simple)
```
  
## Extending model across areas
  
First, it's useful to look at the number of vessels that can be uniquely assigned to each of our areas. This shows that > 80% of vessels never fish in more than 1 of our coarse areas (Prince William Sound, Cook Inlet, Bristol Bay, E/W Kodiak, etc), so we can start our analysis focusing on those.  
```{r tableVesselArea}
tableVesselArea = table(cfecClean$adfg, cfecClean$area)
tableVesselArea = ceiling(tableVesselArea/1.0e10)
T = table(apply(tableVesselArea,1,sum))
m = matrix(NA, 3, 2)
colnames(m) = c("# Vessels", "Percent")
rownames(m) = c("1","2","3+")
m[,1] = c(T[2],T[3],sum(T[-c(1:3)]))
m[,2] = round(100*m[,1]/sum(m[,1]),3)

kable(m) # Make simple table w/ knitr
```
  
Next, we'll extract the vessels that are only assigned to one area, subsetting the entire dataset to just these vessels.
```{r }
singleAreaVessels = rownames(tableVesselArea)[which( apply(tableVesselArea, 1, sum) == 1)]
cfecClean$adfg = as.character(cfecClean$adfg)
cfecSingles = group_by(cfecClean, adfg) %>% 
  mutate(is_Single = any(adfg %in% singleAreaVessels)) %>%
  as.data.frame() %>%
  filter(is_Single) %>%
  data.frame
```
  
We can re-run the code above to total the response / predictors by calendar year. We'll add a column for area. 
```{r aggregateSingleVessel}
totalSingles = group_by(cfecSingles, adfg, year) %>%
  summarize(totalearnings = sum(g_earn), 
            nspecies = length(unique(spec)),  
            ngear = length(unique(gearn)),  
            narea = length(unique(area)), 
            nfishery = length(unique(p_fshy))) 
# Lump larger groups
totalSingles$nspecies[totalSingles$nspecies > 10] = 10
totalSingles$narea[totalSingles$narea > 2] = 2
totalSingles$ngear[totalSingles$ngear > 3] = 3
totalSingles$nfishery[totalSingles$nfishery > 4] = 4

# Add areas
totalSingles$area = NA
for(i in 1:length(colnames(tableVesselArea))) {
  totalSingles$area[totalSingles$adfg %in% rownames(tableVesselArea)[which(tableVesselArea[, i] == 1)]] = colnames(tableVesselArea)[i]
}

# Fill in missing years and difference
dummyDF = expand.grid(adfg = unique(totalSingles$adfg), 
 year =  min(totalSingles$year) : max(totalSingles$year), 
 stringsAsFactors = F)
# expand the data frame w/missing years
totalSingles = left_join(dummyDF, totalSingles) %>%
  arrange(adfg, year)
totalSingles = group_by(totalSingles, adfg) %>%
  mutate(difflog = c(NA, diff(log(totalearnings))), 
         diffspec = c(NA, diff(nspecies)), 
         diffgear = c(NA, diff(ngear)), 
         diffarea = c(NA, diff(narea)), 
         difffishery = c(NA, diff(nfishery))) %>%
  filter(!is.na(difflog))
```
  
Fit another gam, with shared coefficients across areas, but different splines over time by area (Note 'narea' and 'diffarea' aren't included because this model only includes vessels fishing in one area). These don't include quartiles like previous plots, but show that annual patterns are different (and more variable, as function of sample size) across regions. We'll use something like hierarchical linear models to do a better job of modeling these parameters. 
  
```{r simpleAreaGam, fig.pos="placeHere",fig.cap="Simple GAM model, grouped by area, with area specific effects of species and change in species fished. Gears, change in gears, areas, and change in areas fished also included. Plots show mean smooth year term, with SE."}
gam.area = gam(difflog~area + s(year,by=as.factor(area)) + area*nspecies + area*diffspec + ngear + diffgear,data=totalSingles)
summary(gam.area)
par(mfrow = c(3,2),mgp=c(2,1,0),mai=c(0.5,0.5,0.3,0.1))
plot(gam.area)
```


## To do list
1. Fit GAMs to diversity metrics to characterize change over time. This could be done with the full dataset, 1985-present. 
2. We're going to repeat this kind of analysis on different areas. Some things to consider are:  
- for estimation of random effects, we may need to only include vessels with 3+ records  
- we may want to think about avoiding double counting. The way we have the sorting set up now, a vessel fishing in SEAK and PWS would be counted in both areas / analyses
3. For comparison between areas, we're interested in characterizing differences in year to year patterns, whether or not diversity relationships/coefficients are shared or random across areas (shared vs random effects), and possibly whether impacts of diversity are changing over time (think DLMs).

******
# More rigorous analysis  

Above, we focued on breaking the paper into 2 parts: (1) analyzing patterns over time in diversity by fitting GAMs, and then (2) doing statistical modeling of change in revenue as a function of diversification metrics. 

## Change in diversity metrics through time  

We're going to do some harder filtering, first only retaining vessels / permits that ever fished in one of the designated areas. In other words, they can't have an NA in the record - ever. 

```{r}
cfecCleaned = cfecClean
cfecCleaned$isNA = 0 # is an area ever NA?
cfecCleaned$isNA[is.na(cfecCleaned$area)] = 1
vessel.isna = table(cfecCleaned$adfg,cfecCleaned$isNA)
cfecCleaned = cfecCleaned[cfecCleaned$adfg %in% names(which(vessel.isna[, 2] ==
0)), ]
```

```{r}
# Of this restricted dataset, 93% of vessels don't move between areas -
# ever. So the primary focus of our analysis can be on gears and species
# landed. Just so the area switching won't matter, let's delete those
# records that have multiple areas
t = ceiling(table(cfecCleaned$adfg, cfecCleaned$area)/1e+10)
# delete vessels that fish in 2+ areas
cfecCleaned = cfecCleaned[cfecCleaned$adfg %in% names(which(apply(t, 1, sum) ==
1)), ]

# Now tabulate summaries of species, gears, fisheries, etc
totalVessels = group_by(cfecCleaned, adfg, year) %>%  
  summarize(totalearnings = sum(g_earn),  
  nspecies = length(unique(spec)),  
  ngear = length(unique(gearn)),  
  nfishery = length(unique(p_fshy)),
  area = area[1])  

# calculate landings by species, year, vessel
landBySpec = group_by(cfecCleaned, adfg, year, spec) %>%  
summarize(totalpounds = sum(g_pounds))  
# calculate effective number of species by exp() for shannon
# http://jonlefcheck.net/2012/10/23/diversity-as-effective-numbers/
landBySpec = group_by(landBySpec, adfg, year) %>%  
   summarize(effectiveSpec = exp(diversity(totalpounds)))

totalVessels$effectiveSpec = landBySpec$effectiveSpec

# calculate landings by gear, year, vessel
landByGear = group_by(cfecCleaned, adfg, year, gearn) %>%  
  summarize(totalpounds = sum(g_pounds))  
landByGear = group_by(landByGear, adfg, year) %>%  
  summarize(effectiveGear = exp(diversity(totalpounds)))  

totalVessels$effectiveGear = landByGear$effectiveGear  

# calculate landings by fishery, year, vessel
landByFshy = group_by(cfecCleaned, adfg, year, p_fshy) %>%  
summarize(totalpounds = sum(g_pounds))  
landByFshy = group_by(landByFshy, adfg, year) %>%  
summarize(effectiveFshy = exp(diversity(totalpounds)))  

totalVessels$effectiveFshy = landByFshy$effectiveFshy  

# Lump larger groups
totalVessels$nspecies[totalVessels$nspecies > 10] = 10
totalVessels$ngear[totalVessels$ngear > 3] = 3
totalVessels$nfishery[totalVessels$nfishery > 4] = 4
```

### GAM fitting  

Without area included, our 3 dimensions are (1) species, (2) gears, and (3) fisheries. For both metrics, we can fit GAMS examining either the raw counts, or use the effective number, which we calculated above. For each diversity metric, we can also do model selection to ask whether the spline over time is constant or shared across areas. 

#### Change in species over time  

We can fit 4 models to the species data. We're not comparing Raw / Effective counts, but constant versus area-specific splines. We can see that the area splines are strongly favored, suggesting regional patterns in diversity with respect to species. 
```{r}
rawspec.ConstantSpline = gam(log(nspecies) ~ s(year), data=totalVessels)
rawspec.AreaSpline = gam(log(nspecies) ~ s(year, by = as.factor(area)), data=totalVessels)
effspec.ConstantSpline = gam(log(effectiveSpec) ~ s(year), data=totalVessels)
effspec.AreaSpline = gam(log(effectiveSpec) ~ s(year, by = as.factor(area)), data=totalVessels)
spec.mat = matrix(c("Raw","Raw","Effective","Effective", "Constant", "Area", "Constant", "Area", 
             round(AIC(rawspec.ConstantSpline),2), round(AIC(rawspec.AreaSpline),2), round(AIC(effspec.ConstantSpline),2), round(AIC(effspec.AreaSpline),2)), 4, 3)
colnames(spec.mat) = c("Counts", "Spline", "AIC")
kable(spec.mat)
```

#### Change in gears over time  

We can fit the same 4 models to the gear data. We're not comparing Raw / Effective counts, but constant versus area-specific splines. Like with species, the area splines are strongly favored, suggesting regional patterns in diversity with respect to gears fished.  
```{r}
rawgear.ConstantSpline = gam(log(ngear) ~ s(year), data=totalVessels)
rawgear.AreaSpline = gam(log(ngear) ~ s(year, by = as.factor(area)), data=totalVessels)
effgear.ConstantSpline = gam(log(effectiveGear) ~ s(year), data=totalVessels)
effgear.AreaSpline = gam(log(effectiveGear) ~ s(year, by = as.factor(area)), data=totalVessels)
gear.mat = matrix(c("Raw","Raw","Effective","Effective", "Constant", "Area", "Constant", "Area", 
             round(AIC(rawgear.ConstantSpline),2), round(AIC(rawgear.AreaSpline),2), round(AIC(effgear.ConstantSpline),2), round(AIC(effgear.AreaSpline),2)), 4, 3)
colnames(gear.mat) = c("Counts", "Spline", "AIC")
kable(gear.mat)
```

#### Change in fisheries over time  

We can fit the same 4 models to the fishery data. We're not comparing Raw / Effective counts, but constant versus area-specific splines. Like with species and gears, the area splines are strongly favored, suggesting regional patterns in diversity with respect to fisheries fished. 
```{r}
rawfshy.ConstantSpline = gam(log(nfishery) ~ s(year), data=totalVessels)
rawfshy.AreaSpline = gam(log(nfishery) ~ s(year, by = as.factor(area)), data=totalVessels)
efffshy.ConstantSpline = gam(log(effectiveFshy) ~ s(year), data=totalVessels)
efffshy.AreaSpline = gam(log(effectiveFshy) ~ s(year, by = as.factor(area)), data=totalVessels)
fshy.mat = matrix(c("Raw","Raw","Effective","Effective", "Constant", "Area", "Constant", "Area", round(AIC(rawfshy.ConstantSpline),2), round(AIC(rawfshy.AreaSpline),2), round(AIC(efffshy.ConstantSpline),2), round(AIC(efffshy.AreaSpline),2)), 4, 3)
colnames(fshy.mat) = c("Counts", "Spline", "AIC")
kable(fshy.mat)
```

So in all cases, the diversity changes over time varies spatially. Finally, we'll plot the model output for the best models. 

```{r, fig.pos="placeHere",fig.cap="GAM predictions of responses (species, gears, fisheries) by metric (raw, effective). Colors represent regions."}
# make a 3 x 2 plot with diversity measure on rows, and raw/effect on cols
areas = levels(as.factor(totalVessels$area))
ys = 1985:2014
par(mfrow = c(3,2), mgp=c(2,1,0), mai=c(0.5,0.5,0.05,0.05))
# BristolBay CookInlet Kodiak.east Kodiak.west PWS Southeast

plot(ys, predict(rawspec.AreaSpline, 
newdata=expand.grid(area="BristolBay",year=ys)), type="l", 
col = tim.colors(6)[1], ylim=c(0, max(rawspec.AreaSpline$fitted.values)), 
xlab="", ylab = "Predicted log(raw spec)")
for(i in 2:length(areas)) {
lines(ys, predict(rawspec.AreaSpline, newdata=expand.grid(area=areas[i],year=ys)), col = tim.colors(6)[i])
}
legend("topleft", areas, col = tim.colors(6), lty=1, bty="n")

plot(ys, predict(effspec.AreaSpline, 
newdata=expand.grid(area="BristolBay",year=ys)), type="l", 
col = tim.colors(6)[1], ylim=c(0, max(effspec.AreaSpline$fitted.values)), 
xlab="", ylab = "Predicted log(eff. spec)")
for(i in 2:length(areas)) {
lines(ys, predict(effspec.AreaSpline, newdata=expand.grid(area=areas[i],year=ys)), col = tim.colors(6)[i])
}

plot(ys, predict(rawgear.AreaSpline, 
newdata=expand.grid(area="BristolBay",year=ys)), type="l", 
col = tim.colors(6)[1], ylim=c(0, max(rawgear.AreaSpline$fitted.values)), 
xlab="", ylab = "Predicted log(raw gears)")
for(i in 2:length(areas)) {
lines(ys, predict(rawgear.AreaSpline, newdata=expand.grid(area=areas[i],year=ys)), col = tim.colors(6)[i])
}

plot(ys, predict(effgear.AreaSpline, 
newdata=expand.grid(area="BristolBay",year=ys)), type="l", 
col = tim.colors(6)[1], ylim=c(0, max(effgear.AreaSpline$fitted.values)), 
xlab="", ylab = "Predicted log(eff gears)")
for(i in 2:length(areas)) {
lines(ys, predict(effgear.AreaSpline, newdata=expand.grid(area=areas[i],year=ys)), col = tim.colors(6)[i])
}

plot(ys, predict(rawfshy.AreaSpline, 
newdata=expand.grid(area="BristolBay",year=ys)), type="l", 
col = tim.colors(6)[1], ylim=c(0, max(rawfshy.AreaSpline$fitted.values)), 
xlab="", ylab = "Predicted log(raw fshy)")
for(i in 2:length(areas)) {
lines(ys, predict(rawfshy.AreaSpline, newdata=expand.grid(area=areas[i],year=ys)), col = tim.colors(6)[i])
}

plot(ys, predict(efffshy.AreaSpline, 
newdata=expand.grid(area="BristolBay",year=ys)), type="l", 
col = tim.colors(6)[1], ylim=c(0, max(efffshy.AreaSpline$fitted.values)), 
xlab="", ylab = "Predicted log(eff fshy)")
for(i in 2:length(areas)) {
lines(ys, predict(efffshy.AreaSpline, newdata=expand.grid(area=areas[i],year=ys)), col = tim.colors(6)[i])
}
```

## Clustering vessel-years by diversity in species  

Our response (revenue) and predictors are on an annual scale, so one analysis that might be interesting to look at would be to try to reduce the dimension of the dataset. In other words, is it possible to classify vessel-year landings into salmon v non-salmon fishers? Or are other patterns of specialists evident? 

One way to do this is to create a matrix with rows = vessel-year combinations, and columns = species landed.

```{r}
# summarize landings by year/spec/
totalLandings = group_by(cfecCleaned, adfg, year, spec) %>%  
  summarize(totallandings = sum(g_pounds))
# cast to wide format with species across cols
totalLandings = as.data.frame(totalLandings)
#totalLandings = totalLandings[-which(is.na(totalLandings$adfg)),]
lmlt <- melt(totalLandings, id.vars = c("adfg", "year","spec"))
newdf <- dcast(lmlt, year + adfg ~ spec)
```

Now we can apply MDS to look at clusters. Turn all NAs to 0s. 

```{r}
for(i in 3:dim(newdf)[2]) {
  newdf[which(is.na(newdf[,i])),i] = 0
  #newdf[,i] = as.numeric(newdf[,i])
}
# Let's sample ~ 10000 data points for starters
s = sample(seq(1, dim(newdf)[1]), size=5000, replace=F)
#distMat = dist(log(newdf[s,-c(1:2)]+1))

#avgWidth = 100
#for(i in 2:10) {
#  clust = pam(log(newdf[s,-c(1:2)]+1), k = i)
#  avgWidth[i] = clust$silinfo$avg.width
#}
#bestClust = which.min(avgWidth)

# Using mean(silhouette(clust)) we find that 3 clusters
# has the lowest mean silhouette width
bestClust = 3
clust = pam(log(newdf[s,-c(1:2)]+1), k = bestClust)

# We can look at what the medoids represent, 
m = t(clust$medoids)
colnames(m) = paste("Group",seq(1,dim(m)[2]))
kable(m)
```
  
What follows out here is that the data are dividing annual landings into 3 larger groups: Sockeye fishing, Non-sockeye salmon fishing, and halibut fishing (PHLB).  

Just for general interest, we could basically repeat the same analysis after dropping out the salmon records. This shows that herring and halibut landings are the largest groups (and everything else as 3rd group).

```{r}
#avgWidth = 100
dropnames = which(colnames(newdf)%in%c("year", "adfg", "CHNK", "CHUM", "COHO", "PINK", "SOCK"))
#for(i in 2:10) {
#  clust = pam(log(newdf[s,-dropnames]+1), k = i)
#  avgWidth[i] = clust$silinfo$avg.width
#}
#bestClust = which.min(avgWidth)
# Using mean(silhouette(clust)) we find that 3 clusters
# has the lowest mean silhouette width
bestClust=3
clust = pam(log(newdf[s,-dropnames]+1), k = bestClust)

# We can look at what the medoids represent, 
m = t(clust$medoids)
colnames(m) = paste("Group",seq(1,dim(m)[2]))
kable(m)
```

One potential criticism of this approach is that the separation / group medoids are largely affected by landed weight. An alternative approach would be to do the same clustering using binary classification with 'mona'. 

```{r}
newdf01 = ceiling(newdf[,-c(1:2)]/1.0e10)
avgWidth = 100
dropnames = which(colnames(newdf)%in%c("year", "adfg", "CHNK", "CHUM", "COHO", "PINK", "SOCK"))
for(i in 2:10) {
  clust = pam(log(newdf01[s,-dropnames]+1), k = i)
  avgWidth[i] = clust$silinfo$avg.width
}

bestClust = which.min(avgWidth)
clust = pam(log(newdf01[s,-dropnames]+1), k = bestClust)

# We can look at what the medoids represent, 
m = t(clust$medoids)
colnames(m) = paste("Group",seq(1,dim(m)[2]))
kable(m)
```

So basically the groups are the same before, with 2 kinds of salmon fishermen and halibut defining the 3rd cluster.

## Linear modeling of changing diversity on revenue  

Add in NAs for missing years. For the undifferenced data, the number of species, gears, etc. corresponds to the value in the second year. We may want to replace this with a 2-year mean or something.

```{r}
dummyDF = expand.grid(adfg = unique(totalVessels$adfg), 
  year = min(totalVessels$year) : max(totalVessels$year),
  stringsAsFactors = F)

# expand the data frame w/missing years
totalVesselsExp = left_join(dummyDF, totalVessels) %>%
  arrange(adfg, year)
totalVesselsExp = group_by(totalVesselsExp, adfg) %>%
  mutate(difflog = c(NA, diff(log(totalearnings))),  
         diffspec = c(NA, diff(nspecies)),  
         diffgear = c(NA, diff(ngear)),  
         difffishery = c(NA, diff(nfishery)),  
         diffeffspec = c(NA, diff(effectiveSpec)),  
         diffeffgear = c(NA, diff(effectiveGear)),  
         diffefffishery = c(NA, diff(effectiveFshy))) %>%  
  filter(!is.na(difflog))
```

We may also want to calculate the weighted average of each of the predictors, with weights being pounds landed. For example, if someone catches 2000 kg of sockeye and 5 kg of chum, the weights may better reflect divserification. 

## Inclusion of vessel random effects  

Were modeling revenue (or change in revenue) across a large number of vessels (5000+). One way to make this model hierarchical would be to include random effects in vessel. The intercept here represents Bristol Bay in 1986  all factors (year / area) are offsets.

```{r}
lme.vess.1trend = lmer(difflog ~ area + as.factor(year) + 
  nspecies + diffspec + ngear + diffgear + (1 | adfg), 
  data = totalVesselsExp)
summary(lme.vess.1trend)
```

We can plot the overall annual trend for Bristol Bay, the patterns for other regions are all just offset from the Bristol Bay trend.

```{r, fig.pos="placeHere",fig.cap="Mixed effects model output of fixed year effects for the Bristol Bay region."}
ycoef = c(0, fixef(lme.vess.1trend)[7:34])
ycoef = ycoef + fixef(lme.vess.1trend)[1]
plot(1986:2014, ycoef, type = "b", xlab = "", 
     ylab = "Year effect across vessels in Bristol Bay")
```

The key point here is that inclusion of random effects, or more complicated interactions (below) doesnt change the magnitude or sign of the fixed coefficients we care about  namely, the number of species fished (and change) or number of gears fished (and change). These more complicated models are largely a way to think about how the larger trends / year-to-year variability are changing across space.  

Next, we can make the model maybe a little more realistic by allowing the year effects to vary over space, by including a year x area interaction.

```{r}
lme.vess.int = lmer(difflog ~ area * as.factor(year) + nspecies + diffspec + ngear + diffgear + (1 | adfg), data = totalVesselsExp)
summary(lme.vess.int)
```

Does this improve the model? Based on the AIC values, the answer is yes. One of the interesting things with both models is that both 'diffspec' and 'diffgear' are statistically significant, and have positive effects [interpretation: increasing either species landed or gears fished from one year to the next increases revenue].

```{r}
m = matrix(c("1 trend", "Regional trends", round(AIC(lme.vess.1trend), 1), round(AIC(lme.vess.int), 1)), 2, 2)
colnames(m) = c("Model", "AIC")
kable(m)
```

We can look at how the year effects vary by region:

```{r, fig.pos="placeHere",fig.cap="Fixed effects by region from the mixed effects model (represents area x time interaction)."}
coef.bb = c(0, fixef(lme.vess.int)[7:34])# Bristol Bay
coef.ci = coef.bb + fixef(lme.vess.int)[2] + 
  c(0, fixef(lme.vess.int)[grep("areaCookInlet",  
  names(fixef(lme.vess.int)))[-1]])
coef.ke = coef.bb + fixef(lme.vess.int)[3] + 
  c(0, fixef(lme.vess.int)[grep("areaKodiak.east", 
  names(fixef(lme.vess.int)))[-1]])
coef.kw = coef.bb + fixef(lme.vess.int)[4] + 
  c(0, fixef(lme.vess.int)[grep("areaKodiak.west", 
  names(fixef(lme.vess.int)))[-1]])
coef.pw = coef.bb + fixef(lme.vess.int)[5] + 
  c(0, fixef(lme.vess.int)[grep("areaPWS", 
  names(fixef(lme.vess.int)))[-1]])
coef.se = coef.bb + fixef(lme.vess.int)[6] + 
  c(0, fixef(lme.vess.int)[grep("areaSoutheast", 
  names(fixef(lme.vess.int)))[-1]])

plot(1986:2014, coef.bb, type = "l", col = tim.colors(6)[1], ylim = c(-2, 2), ylab = "Year effects by region")
lines(1986:2014, coef.ci, type = "l", col = tim.colors(6)[2])
lines(1986:2014, coef.kw, type = "l", col = tim.colors(6)[3])
lines(1986:2014, coef.ke, type = "l", col = tim.colors(6)[4])
lines(1986:2014, coef.se, type = "l", col = tim.colors(6)[5])
lines(1986:2014, coef.pw, type = "l", col = tim.colors(6)[6])
legend("topleft", c("Bristol Bay", "Cook Inlet", "Kodiak - east", "Kodiak - west",
"Southeast", "PWS"), col = tim.colors(6), lty = 1)
```

But if we look at the model output more closely, we see that the variance of the vessel specific random effects is driven to 0. This may be because of the large number of vessels with single values (remember, each value indicates a vessel that fishes in consecutive years, because our response is based on the difference).

```{r}
 # Calculate proportion of vessels with 1 observation
round(length(table(totalVesselsExp$adfg))/length(which(table(totalVesselsExp$adfg) == 1)), 2)
```

We could also refine the model to concentrate on vessels that we more active  e.g. vessels with 10 or more years of observations.

```{r}
activeVess = names(which(table(totalVesselsExp$adfg) >= 10))
lme.vess.int10 = lmer(difflog ~ area + as.factor(year) + nspecies + diffspec +
    ngear + diffgear + (1 | adfg), data = totalVesselsExp[totalVesselsExp$adfg %in%
activeVess, ])
summary(lme.vess.int10)
```

It might be worth looking at these active vessels, and going back to the original data to get a better sense for the relationship between increasing species fished and increasing profit.

```{r, fig.pos="placeHere",fig.cap="Individual performance (log total revenue in red) and species landed (raw = black, effective = blue)."}
activeVess = names(which(table(totalVesselsExp$adfg) >= 10))
activeVess.id = names(rev(sort(table(totalVesselsExp[totalVesselsExp$adfg %in% activeVess, ]$adfg))))

par(mfrow = c(5, 5), mai = c(0.01, 0.01, 0.01, 0.01))
for (i in 1:25) {
  df = as.data.frame(totalVesselsExp[totalVesselsExp$adfg == activeVess.id[i], ])
  plot(df$nspecies, type = "l")
  lines(rescale(log(df$totalearnings), range(df$nspecies)), col = "red")
  lines(rescale(log(df$effectiveSpec), range(df$nspecies)), col = "blue")
}
```

Another way to make the model more complex would be to allow for time varying effects. For all models above, the variable diffspec is the strongest, so we could allow this variable to vary over time and / or space.

```{r}
lme.vess.int.area = lmer(difflog ~ area * as.factor(year) + nspecies + area * diffspec + ngear + diffgear + (1 | adfg), data = totalVesselsExp)
lme.vess.int.time = lmer(difflog ~ area * as.factor(year) + nspecies + as.factor(year) * diffspec + ngear + diffgear + (1 | adfg), data = totalVesselsExp)
lme.vess.int.timearea = lmer(difflog ~ area * as.factor(year) + nspecies + area * as.factor(year) * diffspec + ngear + diffgear + (1 | adfg), data = totalVesselsExp)
```

In this case, the comparison among the three models suggests that theres more support for the coefficient varying spatially and temporally. [interpretation: the benefit of increasing species landed varies over time, and has a different pattern for each spatial region included here].

```{r}
m = matrix(c("Area", "Time", "Area-Time", round(AIC(lme.vess.int.area), 1), round(AIC(lme.vess.int.time), 1), round(AIC(lme.vess.int.timearea), 1)), 3, 2)
colnames(m) = c("Model of diffspec", "AIC")
kable(m)
```

We can also explore whether the effective number of species fished is a better proxy for species diversity, in comparing our two variables. 

```{r}
lme.vess.int.area.effective = lmer(difflog ~ area * as.factor(year) + effectiveSpec + area * diffspec + effectiveGear + diffeffgear + (1 | adfg), data = totalVesselsExp)
```


